import os
import json
import re
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime
import google.generativeai as genai

logger = logging.getLogger(__name__)

class DocumentationGenerator:
    """Advanced documentation generator using AI"""
    
    def __init__(self):
        """Initialize the documentation generator"""
        self.gemini_api_key = os.getenv('GEMINI_API_KEY')
        
        # if self.gemini_api_key:
        #     genai.configure(api_key=self.gemini_api_key)
        #     self.model = genai.GenerativeModel('gemini-pro')
        # else:
        logger.warning("Gemini API key not found. Documentation generation will be limited.")
        self.model = None
    
    def check_health(self) -> bool:
        """Check if the documentation generator is healthy"""
        return self.model is not None
    
    def generate_documentation(self, analysis_result: Dict[str, Any], rag_result: Dict[str, Any]) -> Dict[str, Any]:
        """Generate comprehensive documentation from analysis results"""
        logger.info("Starting documentation generation")
        
        documentation = {
            'readme': self._generate_readme(analysis_result, rag_result),
            'api_docs': self._generate_api_documentation(analysis_result),
            'setup_guide': self._generate_setup_guide(analysis_result),
            'architecture_docs': self._generate_architecture_docs(analysis_result),
            'contributing_guide': self._generate_contributing_guide(analysis_result),
            'changelog': self._generate_changelog_template(analysis_result),
            'deployment_guide': self._generate_deployment_guide(analysis_result),
            'testing_guide': self._generate_testing_guide(analysis_result),
            'troubleshooting': self._generate_troubleshooting_guide(analysis_result),
            'additional_files': self._generate_additional_files(analysis_result)
        }
        
        logger.info("Documentation generation completed")
        return documentation
    
    def _generate_readme(self, analysis_result: Dict[str, Any], rag_result: Dict[str, Any]) -> str:
        """Generate a comprehensive README.md file"""
        repo_info = analysis_result.get('repository_info', {})
        metadata = analysis_result.get('metadata', {})
        file_structure = analysis_result.get('file_structure', {})
        code_analysis = analysis_result.get('code_analysis', {})
        
        # Get project name and description
        project_name = repo_info.get('repo', 'Unknown Project')
        description = metadata.get('description', 'A software project')
        
        # Determine main language and framework
        main_language = code_analysis.get('main_language', 'Unknown')
        frameworks = code_analysis.get('frameworks', [])
        
        # Generate README content
        readme_content = f"""# {project_name}

{description}

## 🚀 Overview

This is a {main_language} project"""
        
        if frameworks:
            readme_content += f" built with {', '.join(frameworks)}"
        
        readme_content += f""".

### ✨ Features

{self._generate_features_list(analysis_result)}

### 🛠️ Technology Stack

{self._generate_tech_stack(analysis_result)}

## 📋 Prerequisites

{self._generate_prerequisites(analysis_result)}

## 🔧 Installation

{self._generate_installation_instructions(analysis_result)}

## 🚀 Usage

{self._generate_usage_instructions(analysis_result)}

{self._generate_api_section(analysis_result)}

## 🏗️ Project Structure

```
{self._generate_project_structure(file_structure)}
```

## 🧪 Testing

{self._generate_testing_section(analysis_result)}

## 📝 Contributing

{self._generate_contributing_section()}

## 📄 License

{self._get_license_info(metadata)}

## 🤝 Support

{self._generate_support_section(repo_info, metadata)}

---

*This documentation was automatically generated by Documentation.AI*
"""
        
        return readme_content
    
    def _generate_features_list(self, analysis_result: Dict[str, Any]) -> str:
        """Generate a list of project features based on analysis"""
        code_analysis = analysis_result.get('code_analysis', {})
        frameworks = code_analysis.get('frameworks', [])
        api_endpoints = code_analysis.get('api_endpoints', [])
        database_usage = code_analysis.get('database_usage', [])
        
        features = []
        
        # Add framework-based features
        if 'Flask' in frameworks or 'Django' in frameworks or 'FastAPI' in frameworks:
            features.append("🌐 RESTful API endpoints")
        
        if 'React' in frameworks or 'Vue.js' in frameworks or 'Angular' in frameworks:
            features.append("⚡ Modern frontend interface")
        
        if database_usage:
            features.append(f"💾 Database integration ({', '.join(database_usage)})")
        
        if api_endpoints:
            features.append(f"🔗 {len(api_endpoints)} API endpoints")
        
        # Add generic features
        features.extend([
            "🔧 Easy setup and configuration",
            "📚 Comprehensive documentation",
            "🧪 Automated testing suite",
            "🚀 Production-ready deployment"
        ])
        
        return '\n'.join(f"- {feature}" for feature in features)
    
    def _generate_tech_stack(self, analysis_result: Dict[str, Any]) -> str:
        """Generate technology stack information"""
        code_analysis = analysis_result.get('code_analysis', {})
        file_structure = analysis_result.get('file_structure', {})
        
        main_language = code_analysis.get('main_language', 'Unknown')
        frameworks = code_analysis.get('frameworks', [])
        database_usage = code_analysis.get('database_usage', [])
        dependencies = code_analysis.get('dependencies', [])
        
        tech_stack = f"""
**Primary Language:** {main_language}

**Frameworks & Libraries:**
"""
        
        if frameworks:
            tech_stack += '\n'.join(f"- {framework}" for framework in frameworks)
        else:
            tech_stack += "- Standard library components"
        
        if database_usage:
            tech_stack += f"\n\n**Database:**\n"
            tech_stack += '\n'.join(f"- {db}" for db in database_usage)
        
        if dependencies:
            key_deps = [dep['name'] for dep in dependencies[:5]]  # Show top 5 dependencies
            tech_stack += f"\n\n**Key Dependencies:**\n"
            tech_stack += '\n'.join(f"- {dep}" for dep in key_deps)
        
        return tech_stack
    
    def _generate_prerequisites(self, analysis_result: Dict[str, Any]) -> str:
        """Generate prerequisites section"""
        code_analysis = analysis_result.get('code_analysis', {})
        main_language = code_analysis.get('main_language', '')
        
        prerequisites = []
        
        if main_language == 'Python':
            prerequisites.append("- Python 3.8 or higher")
            prerequisites.append("- pip (Python package manager)")
        elif main_language == 'JavaScript':
            prerequisites.append("- Node.js 14.x or higher")
            prerequisites.append("- npm or yarn package manager")
        elif main_language == 'Java':
            prerequisites.append("- Java 11 or higher")
            prerequisites.append("- Maven or Gradle")
        elif main_language == 'Go':
            prerequisites.append("- Go 1.19 or higher")
        
        # Add Git as a common prerequisite
        prerequisites.append("- Git")
        
        return '\n'.join(prerequisites)
    
    def _generate_installation_instructions(self, analysis_result: Dict[str, Any]) -> str:
        """Generate installation instructions"""
        code_analysis = analysis_result.get('code_analysis', {})
        file_structure = analysis_result.get('file_structure', {})
        repo_info = analysis_result.get('repository_info', {})
        
        main_language = code_analysis.get('main_language', '')
        repo_url = f"https://github.com/{repo_info.get('full_name', 'user/repo')}"
        
        instructions = f"""### 1. Clone the repository

```bash
git clone {repo_url}
cd {repo_info.get('repo', 'project')}
```

### 2. Install dependencies
"""
        
        if main_language == 'Python':
            if 'requirements.txt' in file_structure.get('important_files', []):
                instructions += """
```bash
pip install -r requirements.txt
```"""
            elif 'setup.py' in file_structure.get('important_files', []):
                instructions += """
```bash
pip install -e .
```"""
            else:
                instructions += """
```bash
pip install -r requirements.txt
```"""
        
        elif main_language == 'JavaScript':
            if 'package.json' in file_structure.get('important_files', []):
                instructions += """
```bash
npm install
# or
yarn install
```"""
        
        elif main_language == 'Java':
            instructions += """
```bash
./mvnw install
# or for Gradle
./gradlew build
```"""
        
        instructions += """

### 3. Configuration

Copy the example environment file and configure your settings:

```bash
cp .env.example .env
# Edit .env with your configuration
```"""
        
        return instructions
    
    def _generate_usage_instructions(self, analysis_result: Dict[str, Any]) -> str:
        """Generate usage instructions"""
        code_analysis = analysis_result.get('code_analysis', {})
        file_structure = analysis_result.get('file_structure', {})
        main_language = code_analysis.get('main_language', '')
        frameworks = code_analysis.get('frameworks', [])
        
        usage = "### Starting the application\n\n"
        
        if main_language == 'Python':
            if 'Flask' in frameworks or 'Django' in frameworks or 'FastAPI' in frameworks:
                usage += """```bash
python app.py
# or
python manage.py runserver  # for Django
# or
uvicorn main:app --reload  # for FastAPI
```

The application will be available at `http://localhost:5000` (or the configured port)."""
            else:
                usage += """```bash
python main.py
```"""
        
        elif main_language == 'JavaScript':
            if 'package.json' in file_structure.get('important_files', []):
                usage += """```bash
npm start
# or
yarn start
```

The application will be available at `http://localhost:3000`."""
        
        elif main_language == 'Java':
            usage += """```bash
./mvnw spring-boot:run
# or
java -jar target/application.jar
```"""
        
        usage += """

### Environment Variables

Make sure to set the following environment variables:

- `DATABASE_URL` - Database connection string
- `API_KEY` - Your API key (if applicable)
- `SECRET_KEY` - Application secret key
"""
        
        return usage
    
    def _generate_api_section(self, analysis_result: Dict[str, Any]) -> str:
        """Generate API documentation section"""
        code_analysis = analysis_result.get('code_analysis', {})
        api_endpoints = code_analysis.get('api_endpoints', [])
        
        if not api_endpoints:
            return ""
        
        api_section = """
## 📡 API Endpoints

This project provides the following API endpoints:

"""
        
        # Group endpoints by HTTP method
        endpoints_by_method = {}
        for endpoint in api_endpoints[:10]:  # Limit to first 10 endpoints
            # Extract method and path from endpoint string
            if 'get' in endpoint.lower():
                method = 'GET'
            elif 'post' in endpoint.lower():
                method = 'POST'
            elif 'put' in endpoint.lower():
                method = 'PUT'
            elif 'delete' in endpoint.lower():
                method = 'DELETE'
            else:
                method = 'GET'  # default
            
            # Extract path
            path_match = re.search(r'[\'"]([^\'\"]*)[\'"]', endpoint)
            path = path_match.group(1) if path_match else '/api/endpoint'
            
            if method not in endpoints_by_method:
                endpoints_by_method[method] = []
            endpoints_by_method[method].append(path)
        
        for method, paths in endpoints_by_method.items():
            api_section += f"\n### {method} Endpoints\n\n"
            for path in paths:
                api_section += f"- `{method} {path}`\n"
        
        api_section += """
For detailed API documentation, please refer to the API documentation section below.
"""
        
        return api_section
    
    def _generate_project_structure(self, file_structure: Dict[str, Any]) -> str:
        """Generate project structure tree"""
        important_files = file_structure.get('important_files', [])
        directories = file_structure.get('directories', [])
        
        structure_lines = []
        
        # Add important files at root
        root_files = [f for f in important_files if '/' not in f]
        for file in sorted(root_files):
            structure_lines.append(f"├── {file}")
        
        # Add directories and their contents
        for directory in sorted(directories[:10]):  # Limit to first 10 directories
            structure_lines.append(f"├── {directory}/")
            
            # Add files in this directory
            dir_files = [f for f in important_files if f.startswith(directory + '/')]
            for file in sorted(dir_files):
                relative_file = file[len(directory)+1:]
                structure_lines.append(f"│   ├── {relative_file}")
        
        return '\n'.join(structure_lines)
    
    def _generate_testing_section(self, analysis_result: Dict[str, Any]) -> str:
        """Generate testing section"""
        code_analysis = analysis_result.get('code_analysis', {})
        main_language = code_analysis.get('main_language', '')
        testing_frameworks = code_analysis.get('testing_frameworks', [])
        
        testing_section = ""
        
        if main_language == 'Python':
            testing_section = """```bash
# Run tests with pytest
pytest

# Run tests with coverage
pytest --cov=.

# Run specific test file
pytest tests/test_example.py
```"""
        
        elif main_language == 'JavaScript':
            testing_section = """```bash
# Run tests with npm
npm test

# Run tests with coverage
npm run test:coverage

# Run tests in watch mode
npm run test:watch
```"""
        
        elif main_language == 'Java':
            testing_section = """```bash
# Run tests with Maven
./mvnw test

# Run tests with Gradle
./gradlew test
```"""
        
        else:
            testing_section = """Please refer to the testing framework documentation for your specific technology stack."""
        
        return testing_section
    
    def _generate_contributing_section(self) -> str:
        """Generate contributing section"""
        return """Please read [CONTRIBUTING.md](CONTRIBUTING.md) for details on our code of conduct and the process for submitting pull requests.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request"""
    
    def _get_license_info(self, metadata: Dict[str, Any]) -> str:
        """Get license information"""
        license_info = metadata.get('license', {})
        if license_info and 'name' in license_info:
            return f"This project is licensed under the {license_info['name']} License - see the [LICENSE](LICENSE) file for details."
        else:
            return "This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details."
    
    def _generate_support_section(self, repo_info: Dict[str, Any], metadata: Dict[str, Any]) -> str:
        """Generate support section"""
        repo_url = f"https://github.com/{repo_info.get('full_name', 'user/repo')}"
        
        return f"""If you have any questions or need help, please:

- 📫 Create an issue on [GitHub]({repo_url}/issues)
- 💬 Start a discussion on [GitHub Discussions]({repo_url}/discussions)
- 📧 Contact the maintainers

### Maintainers

- [@{repo_info.get('owner', 'maintainer')}]({repo_url})"""
    
    def _generate_api_documentation(self, analysis_result: Dict[str, Any]) -> str:
        """Generate detailed API documentation"""
        if not self.model:
            return "API documentation generation requires AI model access."
        
        try:
            code_analysis = analysis_result.get('code_analysis', {})
            api_endpoints = code_analysis.get('api_endpoints', [])
            
            if not api_endpoints:
                return "No API endpoints detected in this project."
            
            prompt = f"""
            Generate comprehensive API documentation for the following endpoints:
            {json.dumps(api_endpoints, indent=2)}
            
            Include:
            1. Endpoint descriptions
            2. Request/response formats
            3. Authentication requirements
            4. Example requests and responses
            5. Error handling
            
            Format as markdown.
            """
            
            response = self.model.generate_content(prompt)
            return response.text
            
        except Exception as e:
            logger.error(f"API documentation generation failed: {e}")
            return "API documentation could not be generated automatically."
    
    def _generate_setup_guide(self, analysis_result: Dict[str, Any]) -> str:
        """Generate detailed setup guide"""
        return """# Setup Guide

## Development Environment

### Prerequisites
- Follow the prerequisites listed in the main README

### Local Development Setup

1. **Clone and Setup**
   ```bash
   git clone <repository-url>
   cd <project-name>
   ```

2. **Environment Configuration**
   ```bash
   cp .env.example .env
   # Edit .env with your local configuration
   ```

3. **Database Setup**
   ```bash
   # Create and migrate database
   # (specific commands depend on your database)
   ```

4. **Start Development Server**
   ```bash
   # Start the application in development mode
   ```

### IDE Configuration

Recommended VS Code extensions:
- Language-specific extensions
- Code formatters
- Linters

### Debugging

Instructions for debugging the application locally.
"""
    
    def _generate_architecture_docs(self, analysis_result: Dict[str, Any]) -> str:
        """Generate architecture documentation"""
        code_analysis = analysis_result.get('code_analysis', {})
        frameworks = code_analysis.get('frameworks', [])
        architecture_patterns = code_analysis.get('architecture_patterns', [])
        
        return f"""# Architecture Documentation

## Overview

This document describes the architecture and design patterns used in this project.

## Technology Stack

**Frameworks:** {', '.join(frameworks) if frameworks else 'Standard libraries'}

**Architecture Patterns:** {', '.join(architecture_patterns) if architecture_patterns else 'Standard patterns'}

## System Architecture

[Architecture diagram would go here]

## Component Design

### Core Components

- **Application Layer**: Handles HTTP requests and responses
- **Business Logic Layer**: Contains core application logic
- **Data Access Layer**: Manages data persistence and retrieval

### Design Patterns

The application follows these design patterns:
- MVC (Model-View-Controller)
- Repository Pattern
- Dependency Injection

## Database Design

[Database schema would go here]

## Security Considerations

- Authentication and authorization
- Input validation
- Data encryption
- Security headers

## Performance Considerations

- Caching strategies
- Database optimization
- Load balancing considerations
"""
    
    def _generate_contributing_guide(self, analysis_result: Dict[str, Any]) -> str:
        """Generate contributing guide"""
        return """# Contributing Guide

Thank you for your interest in contributing to this project!

## Code of Conduct

Please read and follow our [Code of Conduct](CODE_OF_CONDUCT.md).

## How to Contribute

### Reporting Bugs

1. Check if the bug has already been reported
2. Create a detailed bug report with:
   - Steps to reproduce
   - Expected behavior
   - Actual behavior
   - Environment details

### Suggesting Features

1. Check existing feature requests
2. Provide a clear description of the feature
3. Explain the use case and benefits

### Code Contributions

1. **Fork the repository**
2. **Create a feature branch**
   ```bash
   git checkout -b feature/your-feature-name
   ```
3. **Make your changes**
4. **Add tests** for your changes
5. **Ensure all tests pass**
6. **Update documentation** if needed
7. **Commit your changes**
   ```bash
   git commit -m "Add: brief description of changes"
   ```
8. **Push to your fork**
   ```bash
   git push origin feature/your-feature-name
   ```
9. **Create a Pull Request**

## Development Guidelines

### Code Style

- Follow the existing code style
- Use meaningful variable and function names
- Add comments for complex logic
- Keep functions small and focused

### Testing

- Write unit tests for new functionality
- Ensure existing tests still pass
- Aim for good test coverage

### Documentation

- Update README.md if needed
- Add docstrings for new functions/classes
- Update API documentation

## Review Process

1. All changes require review
2. Tests must pass
3. Code must follow style guidelines
4. Documentation must be updated

## Getting Help

- Create an issue for questions
- Join our community discussions
- Contact maintainers directly
"""
    
    def _generate_changelog_template(self, analysis_result: Dict[str, Any]) -> str:
        """Generate changelog template"""
        return """# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- New features

### Changed
- Changes to existing functionality

### Deprecated
- Soon-to-be removed features

### Removed
- Removed features

### Fixed
- Bug fixes

### Security
- Security improvements

## [1.0.0] - 2024-01-01

### Added
- Initial release
- Core functionality
- Basic documentation

[Unreleased]: https://github.com/user/repo/compare/v1.0.0...HEAD
[1.0.0]: https://github.com/user/repo/releases/tag/v1.0.0
"""
    
    def _generate_deployment_guide(self, analysis_result: Dict[str, Any]) -> str:
        """Generate deployment guide"""
        code_analysis = analysis_result.get('code_analysis', {})
        main_language = code_analysis.get('main_language', '')
        
        return f"""# Deployment Guide

This guide covers deploying the application to various environments.

## Production Deployment

### Prerequisites

- Production server with {main_language} runtime
- Database server
- Web server (nginx/Apache)
- SSL certificate

### Environment Setup

1. **Server Preparation**
   ```bash
   # Update system packages
   sudo apt update && sudo apt upgrade -y
   ```

2. **Application Deployment**
   ```bash
   # Clone production code
   git clone <repository-url>
   cd <project-name>
   
   # Install dependencies
   # (language-specific commands)
   
   # Set production environment variables
   cp .env.example .env.production
   # Edit with production values
   ```

3. **Database Setup**
   ```bash
   # Create production database
   # Run migrations
   ```

4. **Web Server Configuration**
   ```nginx
   # Nginx configuration example
   server {{
       listen 80;
       server_name yourdomain.com;
       
       location / {{
           proxy_pass http://localhost:5000;
           proxy_set_header Host $host;
           proxy_set_header X-Real-IP $remote_addr;
       }}
   }}
   ```

## Docker Deployment

### Dockerfile
```dockerfile
FROM python:3.9-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 5000

CMD ["python", "app.py"]
```

### Docker Compose
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "5000:5000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
    depends_on:
      - db
  
  db:
    image: postgres:13
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
```

## Cloud Deployment

### Heroku
```bash
# Install Heroku CLI
heroku create your-app-name
git push heroku main
heroku config:set DATABASE_URL=your-db-url
```

### AWS/GCP/Azure
- Container deployment instructions
- Serverless deployment options
- Database configuration

## Monitoring and Logging

- Application monitoring setup
- Log aggregation
- Performance monitoring
- Error tracking
"""
    
    def _generate_testing_guide(self, analysis_result: Dict[str, Any]) -> str:
        """Generate testing guide"""
        return """# Testing Guide

This document outlines the testing strategy and how to run tests.

## Testing Strategy

### Test Types

1. **Unit Tests**
   - Test individual functions/methods
   - Fast execution
   - High coverage

2. **Integration Tests**
   - Test component interactions
   - Database interactions
   - API endpoint testing

3. **End-to-End Tests**
   - Complete user workflows
   - Browser automation
   - Critical path testing

## Running Tests

### Local Testing
```bash
# Run all tests
npm test
# or
pytest

# Run specific test suite
npm test -- --grep "user authentication"
# or
pytest tests/test_auth.py

# Run tests with coverage
npm run test:coverage
# or
pytest --cov=.
```

### Continuous Integration
Tests run automatically on:
- Pull requests
- Commits to main branch
- Scheduled intervals

## Writing Tests

### Test Structure
```python
def test_user_creation():
    # Arrange
    user_data = {"name": "John", "email": "john@example.com"}
    
    # Act
    user = create_user(user_data)
    
    # Assert
    assert user.name == "John"
    assert user.email == "john@example.com"
```

### Best Practices
- Use descriptive test names
- Test edge cases
- Mock external dependencies
- Keep tests independent
- Use test fixtures for setup

## Test Data

### Fixtures
```python
@pytest.fixture
def sample_user():
    return User(name="Test User", email="test@example.com")
```

### Test Database
- Use separate test database
- Reset between tests
- Use factories for test data

## Performance Testing

### Load Testing
```bash
# Example with Apache Bench
ab -n 1000 -c 10 http://localhost:5000/api/endpoint
```

### Benchmarking
- Database query performance
- API response times
- Memory usage monitoring
"""
    
    def _generate_troubleshooting_guide(self, analysis_result: Dict[str, Any]) -> str:
        """Generate troubleshooting guide"""
        return """# Troubleshooting Guide

Common issues and their solutions.

## Installation Issues

### Dependency Conflicts
**Problem**: Package installation fails with dependency conflicts
**Solution**:
```bash
# Clear package cache
npm cache clean --force
# or
pip cache purge

# Reinstall dependencies
rm -rf node_modules package-lock.json
npm install
# or
pip install --force-reinstall -r requirements.txt
```

### Permission Errors
**Problem**: Permission denied errors during installation
**Solution**:
```bash
# Use virtual environment (Python)
python -m venv venv
source venv/bin/activate  # or venv\\Scripts\\activate on Windows

# Use npx for Node.js global packages
npx create-react-app my-app
```

## Runtime Issues

### Database Connection Errors
**Problem**: Cannot connect to database
**Solutions**:
1. Check database server is running
2. Verify connection string in .env
3. Check firewall settings
4. Verify credentials

### Port Already in Use
**Problem**: Address already in use error
**Solution**:
```bash
# Find process using port
lsof -i :5000
# or on Windows
netstat -ano | findstr :5000

# Kill process
kill -9 <PID>
# or on Windows
taskkill /PID <PID> /F
```

### Memory Issues
**Problem**: Out of memory errors
**Solutions**:
1. Increase available memory
2. Optimize database queries
3. Add pagination to large datasets
4. Use streaming for large files

## API Issues

### 404 Not Found
**Problem**: API endpoints return 404
**Solutions**:
1. Check route definitions
2. Verify URL path is correct
3. Check HTTP method (GET, POST, etc.)
4. Review middleware configuration

### CORS Errors
**Problem**: Cross-origin request blocked
**Solution**:
```python
# Enable CORS (Flask example)
from flask_cors import CORS
CORS(app)
```

### Authentication Errors
**Problem**: 401 Unauthorized responses
**Solutions**:
1. Verify API keys are set correctly
2. Check token expiration
3. Review authentication middleware
4. Validate request headers

## Performance Issues

### Slow Database Queries
**Solutions**:
1. Add database indexes
2. Optimize query structure
3. Use connection pooling
4. Consider query caching

### High Memory Usage
**Solutions**:
1. Profile memory usage
2. Fix memory leaks
3. Optimize data structures
4. Use pagination

## Debugging Tips

### Enable Debug Mode
```bash
# Environment variable
export DEBUG=true
# or
export FLASK_ENV=development
```

### Logging
```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

### Common Commands
```bash
# Check logs
tail -f application.log

# Monitor resource usage
top
# or
htop

# Check disk space
df -h
```

## Getting Help

1. Check existing issues on GitHub
2. Search documentation
3. Enable debug logging
4. Create minimal reproduction case
5. Ask for help with detailed error messages
"""
    
    def _generate_additional_files(self, analysis_result: Dict[str, Any]) -> Dict[str, str]:
        """Generate additional documentation files"""
        return {
            'CODE_OF_CONDUCT.md': self._generate_code_of_conduct(),
            'SECURITY.md': self._generate_security_policy(),
            'SUPPORT.md': self._generate_support_doc(),
            '.gitignore': self._generate_gitignore(analysis_result),
            'Dockerfile': self._generate_dockerfile(analysis_result),
            'docker-compose.yml': self._generate_docker_compose(analysis_result)
        }
    
    def _generate_code_of_conduct(self) -> str:
        """Generate code of conduct"""
        return """# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

## Our Standards

Examples of behavior that contributes to a positive environment:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior:

* The use of sexualized language or imagery
* Trolling, insulting or derogatory comments, and personal attacks
* Public or private harassment
* Publishing others' private information without explicit permission
* Other conduct which could reasonably be considered inappropriate

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement.
All complaints will be reviewed and investigated promptly and fairly.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

[homepage]: https://www.contributor-covenant.org
"""
    
    def _generate_security_policy(self) -> str:
        """Generate security policy"""
        return """# Security Policy

## Supported Versions

| Version | Supported          |
| ------- | ------------------ |
| 1.x.x   | :white_check_mark: |
| < 1.0   | :x:                |

## Reporting a Vulnerability

We take security vulnerabilities seriously. Please report security
vulnerabilities responsibly.

### How to Report

1. **Do not** create a public GitHub issue for security vulnerabilities
2. Send an email to [security@project.com] with:
   - Description of the vulnerability
   - Steps to reproduce
   - Potential impact
   - Suggested fix (if any)

### Response Process

1. We will acknowledge receipt within 48 hours
2. We will provide a more detailed response within 5 business days
3. We will work with you to understand and resolve the issue
4. We will notify you when the vulnerability is fixed

### Security Measures

- Regular dependency updates
- Security scanning in CI/CD
- Code review process
- Access controls and authentication
- Data encryption in transit and at rest

Thank you for helping keep our project secure!
"""
    
    def _generate_support_doc(self) -> str:
        """Generate support documentation"""
        return """# Support

## Getting Help

If you need help with this project, here are your options:

### Documentation
- Check the [README](README.md) for basic setup
- Review the [Setup Guide](docs/SETUP.md) for detailed instructions
- See [Troubleshooting](docs/TROUBLESHOOTING.md) for common issues

### Community Support
- 🐛 [Report bugs](../../issues/new?template=bug_report.md)
- 💡 [Request features](../../issues/new?template=feature_request.md)
- 💬 [Join discussions](../../discussions)
- ⭐ Check [existing issues](../../issues)

### Professional Support
For commercial support, training, or consulting:
- Email: [support@project.com]
- Website: [https://project.com/support]

## Response Times

- Bug reports: 2-3 business days
- Feature requests: 1 week
- Security issues: 24-48 hours

## Before Asking for Help

1. Check existing documentation
2. Search existing issues
3. Try the troubleshooting guide
4. Provide a minimal reproduction case

## What to Include in Support Requests

- **Environment**: OS, language version, dependencies
- **Steps to reproduce**: Clear, numbered steps
- **Expected behavior**: What should happen
- **Actual behavior**: What actually happens
- **Error messages**: Full error output
- **Additional context**: Screenshots, logs, etc.

Thank you for using our project!
"""
    
    def _generate_gitignore(self, analysis_result: Dict[str, Any]) -> str:
        """Generate .gitignore file"""
        code_analysis = analysis_result.get('code_analysis', {})
        main_language = code_analysis.get('main_language', '')
        
        gitignore_content = """# General
.DS_Store
.vscode/
.idea/
*.log
*.tmp
temp/
tmp/

# Environment variables
.env
.env.local
.env.production
"""
        
        if main_language == 'Python':
            gitignore_content += """
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual environments
venv/
env/
ENV/
"""
        
        elif main_language == 'JavaScript':
            gitignore_content += """
# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.npm
.yarn-integrity

# Build outputs
build/
dist/
out/

# Next.js
.next/
out/

# React
build/
"""
        
        return gitignore_content
    
    def _generate_dockerfile(self, analysis_result: Dict[str, Any]) -> str:
        """Generate Dockerfile"""
        code_analysis = analysis_result.get('code_analysis', {})
        main_language = code_analysis.get('main_language', '')
        
        if main_language == 'Python':
            return """FROM python:3.9-slim

WORKDIR /app

# Copy requirements and install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose port
EXPOSE 5000

# Set environment variables
ENV FLASK_ENV=production

# Run the application
CMD ["python", "app.py"]
"""
        
        elif main_language == 'JavaScript':
            return """FROM node:16-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy application code
COPY . .

# Build the application
RUN npm run build

# Expose port
EXPOSE 3000

# Start the application
CMD ["npm", "start"]
"""
        
        else:
            return """FROM ubuntu:20.04

WORKDIR /app

# Install dependencies
RUN apt-get update && apt-get install -y \\
    software-properties-common \\
    && rm -rf /var/lib/apt/lists/*

# Copy application code
COPY . .

# Expose port
EXPOSE 8080

# Run the application
CMD ["./start.sh"]
"""
    
    def _generate_docker_compose(self, analysis_result: Dict[str, Any]) -> str:
        """Generate docker-compose.yml"""
        code_analysis = analysis_result.get('code_analysis', {})
        database_usage = code_analysis.get('database_usage', [])
        
        compose_content = """version: '3.8'

services:
  app:
    build: .
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:password@db:5432/myapp
    depends_on:
      - db
    volumes:
      - .:/app
    restart: unless-stopped
"""
        
        # Add database service based on detected database usage
        if 'PostgreSQL' in database_usage or 'postgres' in str(database_usage).lower():
            compose_content += """
  db:
    image: postgres:13
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  postgres_data:
"""
        
        elif 'MySQL' in database_usage or 'mysql' in str(database_usage).lower():
            compose_content += """
  db:
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: myapp
      MYSQL_USER: user
      MYSQL_PASSWORD: password
      MYSQL_ROOT_PASSWORD: rootpassword
    volumes:
      - mysql_data:/var/lib/mysql
    restart: unless-stopped

volumes:
  mysql_data:
"""
        
        elif 'MongoDB' in database_usage or 'mongo' in str(database_usage).lower():
            compose_content += """
  db:
    image: mongo:5.0
    environment:
      MONGO_INITDB_DATABASE: myapp
    volumes:
      - mongo_data:/data/db
    restart: unless-stopped

volumes:
  mongo_data:
"""
        
        return compose_content
